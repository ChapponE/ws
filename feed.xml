<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://chappone.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://chappone.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2023-11-02T09:10:53+00:00</updated><id>https://chappone.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Unfolded neural network for deblur and denoise</title><link href="https://chappone.github.io/blog/2023/mat/" rel="alternate" type="text/html" title="Unfolded neural network for deblur and denoise"/><published>2023-10-16T15:12:00+00:00</published><updated>2023-10-16T15:12:00+00:00</updated><id>https://chappone.github.io/blog/2023/mat</id><content type="html" xml:base="https://chappone.github.io/blog/2023/mat/"><![CDATA[<h2><u>Introduction</u></h2> <p>This project aims to deblur and denoise images, with a focus on the MNIST dataset. The methodology is based on the “Unfolded Forward Backward” approach, developed as part of <a href="https://chappone.github.io/ws/assets/pdf/circumstellar.pdf">my master’s thesis project</a> at ENS Lyon. The code to produce the results of this blog post is available on my <a href="https://github.com/ChapponE/img_deblur">github account</a>.</p> <h2><u>Data</u></h2> <p>I worked with the standard MNIST dataset imported from the Keras library, consisting of 70,000 images, each of size \(28 \times 28\) pixels. To normalize these images, I divided each pixel’s value by 255 to bring them into the range of 0 to 1. To degrade the quality of the handwritten digits, I applied a Gaussian blur with a kernel size of \(7 \times 7\) and a standard deviation of 0.5. Subsequently, I introduced Gaussian noise with a standard deviation of 0.25, resulting in pairs of original and degraded images, as displayed below. We measured the difference between the degraded and original images using the traditional PSNR metric.</p> <div style="text-align: center"><img src="/assets/img/sample.png" alt="A sample image" width="320"/></div> <p>The main objective of this project is to create an estimator for the original image based on the degraded image. The quality of this estimator is assessed using the PSNR metric.</p> <h2><u>Model</u></h2> <p>\(\bullet\) I adopted the classical formalism of inverse problems:<br/> The goal of solving an \(\textit{inverse problem}\) is to create an estimator, denoted as \(\boldsymbol{\widehat{x}} \in \mathbb{R}^{28^2}\), from a set of observed measurements, represented as the degraded images \(\boldsymbol{y} \in \mathbb{R}^{28^2}\). The objective is to create an estimator that is close to the ground truth data, the original image \(\boldsymbol{\bar{x}}\). In our case, we have \(\boldsymbol{y} = A\boldsymbol{\bar{x}} + \mathbf{\epsilon}, \text{ with } A \in \mathbb{R}^{28^2 \times 28^2} \text{ and } \mathbf{\epsilon} \sim \mathbb{N}(\mathbf{0}, \mathbf{\sigma^2 I})\). With \(A\) the gaussian blur and \(\mathbf{\epsilon}\) the gaussian noise.</p> <p>\(\bullet\) The estimator \(\boldsymbol{\widehat{x}}\) for \(\boldsymbol{\bar{x}}\) is typically obtained by solving a variational problem, defined as follows: \(\begin{align} \widehat{\boldsymbol{x}} \in \underset{\boldsymbol{x} \in \mathbb{R}^{28^2}}{\arg \min}\left[\frac{1}{2}||\boldsymbol{y}-A\boldsymbol{x}||_2^2+\mathcal{P}(\boldsymbol{x})\right] \end{align}\) Here, \(||\boldsymbol{y}-A\boldsymbol{x}||_2^2\) represents the data fidelity term, ensuring that the degraded solution \(A\boldsymbol{\widehat{x}}\) is close to the degraded signal \(\boldsymbol{y}\). Additionally, \(\mathcal{P}: \mathbb{R}^{28^2} \rightarrow \mathbb{R}\) is a prior term. For more details on variational problems, you can refer to my Master’s thesis.</p> <p>\(\bullet\) Choosing an appropriate prior term can be challenging. However, once a suitable prior term is chosen, it is possible to find the minimizer of equation (1) using proximal iterative methods like Forward-Backward:<br/> <span><span style="font-weight: bold;">Forward-Backward algorithm:</span><br/> <span style="font-weight: bold;">Assumption:</span> \(\zeta := |||A^*A|||_2&lt;2,\)<br/> <span style="font-weight: bold;">Input:</span> \(\boldsymbol{y}\in \mathbb{R}^{28^2}\), step size \(\tau\in ]0,2\zeta^{-1}[,\)<br/> \(x^0 = A^*y,\)<br/> <span style="font-weight: bold;">For</span> \(n = 0, 1, 2, \ldots\):<br/> \(\quad \quad \tilde{x}^{n}=x^n-\tau A^*(Ax^n - \boldsymbol{y})\);<br/> \(\quad \quad x^{n+1} = \operatorname{prox}_{\tau \mathcal{R}}(\tilde{x}^{n})\);<br/> <span style="font-weight: bold;">Output:</span> \(\lim\limits_{n\rightarrow\infty}{x^n} \in{\arg\min\limits_{x \in \mathbb{R}^{28^2}}}\left[\dfrac{1}{2}||\boldsymbol{y}-A\boldsymbol{x}||_2^2+\mathcal{P}(\boldsymbol{x})\right]\) </span></p> <ul> <li>Remark: Let \(h: \mathcal{H} \rightarrow \mathbb{R},\) \(\forall x \in \mathcal{H} \quad \operatorname{prox}_{\tau h}(x)=\underset{y \in \mathcal{H}}{\operatorname{argmin}} \frac{1}{2 \tau}\|x-y\|^{2}+h(y)\)</li> </ul> <p>\(\bullet\) To address the challenge of selecting a suitable prior term, the iterations of Forward-Backward can be unfolded to learn the prior through deep-learning frameworks. The first unfolded network was introduced in the paper <a href="https://icml.cc/Conferences/2010/papers/449.pdf"> Learning Fast Approximations of Sparse Coding </a> in 2010. To parameterize the unfolded network, I replaced the proximal operator of the prior with UNets, denoted as \(U_{\theta^k}\). To facilitate the learning process, I limited the number of iterations to 5. The algorithm is defined as follows:\(\\\)</p> <p><span><span style="font-weight: bold;">Unfolded Forward-Backward architecture network:</span><br/> <span style="font-weight: bold;">Assumption:</span> \(\zeta:=|||A^*A|||_2 &lt; 2,\, {U_{\theta^k}}_{k\in[0;4]},\) UNets,<br/> <span style="font-weight: bold;">Input:</span> \(\boldsymbol{y}\in \mathbb{R}^{28^2}\), step size \(\tau \in ]0,2\zeta^{-1}[,\)<br/> \(x^0 = A^*y,\)<br/> <span style="font-weight: bold;">For</span> \(n = 0, 1, 2, \ldots 4\):<br/> \(\quad \quad \tilde{x}^{n}=x^n- \tau A^*(y - Ax^n);\)<br/> \(\quad \quad x^{n+1} = U_{\theta^{n+1}}(\tilde{x}^{n})\);<br/> <span style="font-weight: bold;">Output:</span> \(f_\theta(y)=x^5\) </span></p> <p>\(\bullet\) I trained the unfolded network using \(300\) of the \(70\,000\) images from the MNIST dataset. I reserved \(10\,000\) images for testing. It is possible to play with the number of iterations, which corresponds to the layers of our neural network, and the number of scales of the UNets, which determine the size of the UNets. I kept the number of layers fixed at 5 and the number of scales within the set \(\{2, 3, 4\}\).</p> <h2><u>Results</u></h2> <p>\(\bullet\) I minimized the cost function, which is defined as the mean squared error on the \(300\) training images: \(\sum\limits_{i \in [1,300]} \|\bar{x}_i - f_\theta(y)\|^2_2\).</p> <p>\(\bullet\) In the following plot, the training was performed for 50 epochs using the Adam algorithm. The red curve represents the PSNR calculated on the test set, and the blue curve represents the value of the loss function with respect to the number of epochs. Additionally, a table displaying the mean PSNR on the test set, the number of parameters, and the training time is provided.</p> <div style="text-align: center"><img src="/assets/img/curves_mnist.PNG" alt="A sample image" width="820"/></div> <div style="text-align: center"><img src="/assets/img/table_MNIST.png" alt="A sample image" width="490"/></div> <p>\(\bullet\) It is evident that there is no significant difference between the three settings. This can be attributed to the relatively low number of training epochs. In my thesis, it was observed that a higher number of parameters leads to better PSNR results. However, training for hundreds of epochs on my personal computer, which lacks a GPU, is time-consuming. Additionally, it’s noteworthy that the training time increases with a higher number of scales. <br/> Here is an example of a reconstructed sample, demonstrating the quality of the results:</p> <div style="text-align: center"><img src="/assets/img/sample_mnist.png" alt="A sample image" width="820"/></div>]]></content><author><name></name></author><summary type="html"><![CDATA[This project aims to deblur and denoise images, with a focus on the MNIST dataset. The methodology is based on the "Unfolded Forward Backward" approach, developed as part of my master's thesis project at ENS Lyon.]]></summary></entry></feed>