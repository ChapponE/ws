<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Edouard Chappon</title> <meta name="author" content="Edouard Chappon"> <meta name="description" content="This project aims to match the color palette of an original image with that of a target image. It was developed as part of a practical assignment in an optimal transport class."> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?19f3075a2d19613090fe9e16b564e1fe" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/favi.png?b71398e59abbbceb51d3383fe55afffb"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://chappone.github.io/blog/2023/color_transport/"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?e74e74bf055e5729d44a7d031a5ca6a5" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> </head> <body class="theme-red"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Edouard </span>Chappon</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item "> <a class="nav-link" href="/posts/">posts</a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Colour transfert with optimal transport method</h1> <p class="post-meta">November 5, 2023</p> <p class="post-tags"> <a href="/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h2><u>Introduction</u></h2> <p>The objective is to transfer the colormap of an image to make it match that of a target image using optimal transport theory. The code to reproduce the results is available on my <a href="https://github.com/ChapponE/optimal_transport_color_transfer" rel="external nofollow noopener" target="_blank">GitHub account</a>. The algorithm developed and theory come from the articles <a href="https://mural.maynoothuniversity.ie/15125/" rel="external nofollow noopener" target="_blank">Automated colour grading using colour distribution transfer</a> and <a href="https://www.semanticscholar.org/paper/Wasserstein-Barycenter-and-Its-Application-to-Rabin-Peyr%C3%A9/9b208891d1287ebb5b84ac801b41c3313d7e3303" rel="external nofollow noopener" target="_blank">Wasserstein Barycenter and Its Application to Texture Mixing</a>.</p> <h2><u>Representation of the images</u></h2> <p>Because we are interested only in the colors, one image is modeled as a point cloud of \(\mathbb{R}^3\) with a number of points equal to the number of pixels in the image. This means that \(X=\{x_i\}_{i \in [1,N]}\) with \(x_i \in \mathbb{R}^3\) represents an image. If we permute the pixels of an image, it’s representation remains the same. Thus we work in: <br> <span style="display: block; text-align: center;">\(\mathcal{M}=\{[X]; X \in (\mathbb{R}^3)^N \}\) with \([X]=\{(X_{\sigma(j)})_{j=[1,N]}, \sigma \in \Sigma_N\}\), \(\Sigma_N\) is the set of all permutations.</span></p> <h2><u>Wasserstein Distance</u></h2> <p>We define the Wasserstein distance on \(\mathcal{M}\) :<br> <span style="display: block; text-align: center;">\(\forall X,Y \in \mathcal{M}, W(X, Y)^{2}={\min\limits_{\sigma \in \Sigma_{N}}} W_{\sigma}(X, Y) \quad \text { where } \quad W_{\sigma}(X, Y)={\sum\limits_{i \in I}}\left\|X_{i}-Y_{\sigma(i)}\right\|^{2}\) </span> This minimization problem can be computationally expensive, but we can leverage the scalar case (when \(X_i\) and \(Y_i\) are in \(\mathbb{R}\) for \(i \in [1, N]\) instead of being in \((\mathbb{R}^3)^N\)).<br> In this case \(W(X, Y)=W_{\sigma^*}(X, Y)\) with \(\sigma^*=\sigma_Y \circ \sigma_X^{-1}\) where :<br> <span style="display: block; text-align: center;">\(\forall 1 \leq i \leq N, \quad X_{\sigma_{X}(i)} \leq X_{\sigma_{X}(i+1)} \quad \text { and } \quad Y_{\sigma_{Y}(i)} \leqslant Y_{\sigma_{Y}(i+1)}\)</span> It is not computationally costly to calculate \(\sigma\) with fast sorting algorithms. <br> Then we define the sliced Wasserstein Distance \(\tilde{W}\) which is calculated with only 1-D Wasserstein Distances and approximates the wesserstein Distance as follows:<br> <span style="display: block; text-align: center;">\(\forall X, Y \in \mathcal{M}, \tilde{W}(X, Y)^{2}=\int_{\theta \in S^2} {\min\limits_{\sigma_{\theta} \in \Sigma_{N}}} {\sum\limits_{i \in I}} \left\langle X_{i}-Y_{\sigma_{\theta}(i)}, \theta\right\rangle^{2} \mathrm{~d} \theta\)</span> This calculate the Wasserstein Distance using the projected vectors in a certain direction of \(\mathbb{R}^3\) and integrates over all directions. For more details, you can refer to the articles mentioned in the introduction.</p> <h2><u>Barycenter in Wasserstain Space</u></h2> <p>Here we define the barycenter in this space and provide an algorithm to obtain the barycenter of the image we want to transport, weighted at 0, and the image with the desired colormap, weighted at 1. <br> By analogy with the barycenter in Euclidean space, the barycenter in \((\mathcal{M}, \tilde{W})\) is defined as :<br> \(\operatorname{Bar}\left(\lambda_{j}, Y^{j}\right)_{j \in J} \in \underset{X}{\operatorname{argmin}} E(X)\) where \(E(X)={\sum\limits_{j \in J}}\lambda_{j} \tilde{W}\left(X_\theta, Y_\theta^{j}\right)^{2}=\int_{\theta \in S^2}{\sum\limits_{j \in J}}\lambda_j \left\langle X_{i}-Y_{\sigma^*_{\theta}(i)}, \theta\right\rangle^{2} \mathrm{~d} \theta\)<br> With \(X_\theta=\{&lt;X_i,\theta&gt;\}_{i\in[1,N]}\subset \mathbb{R}\) and the \(\sigma^*_\theta\) defined in Wasserstein Distance part.</p> <h2><u>The transportation algorithm:</u></h2> <p>We apply the Wasserstein barycenter with \(\{(0,X);(1,Y)\}\) with \(X\) as the original image (Image 1 in the following figure) we want to transform and \(Y\) as the target image (one of the 5 others) that we want to use to transform \(X\) and use colors.</p> <div style="text-align: center"><img src="/assets/img/ot_6img.PNG" alt="A sample image" width="600"></div> <p>\(\,\) <br> Thus the transported image is defined as:<br> \(\begin{align} X^*=\arg{\min\limits_X}\int_{\theta \in S^2}W(X_\theta, Y_\theta)^2 \mathrm{~d} \theta\end{align}\)<br> We can use gradient descent to find an approximation of this minimizer:<br> <span><span style="font-weight: bold;">Gradient descent to minimize (1):</span><br> <span style="font-weight: bold;">Assumption:</span> Images \(X\) and \(Y\) have the same number of pixels.<br> <span style="font-weight: bold;">Input:</span> \(X\), \(Y\) and a stepsize \(\epsilon\)<br> \(X^{0}=X\)<br> <span style="font-weight: bold;">For</span> \(k = 0, 1, 2, \ldots\):<br> \(\quad \quad X^{k}=X^{k}-\epsilon\nabla W(X^{k}_\theta, Y_\theta)\) with \(\theta\) a realization of an uniform random variable in \(S^2\)<br> <span style="font-weight: bold;">Output:</span> \(\lim\limits_{k\rightarrow\infty}{X^k} \in \arg{\min\limits_X}\int_{\theta \in S^2}W(X_\theta, Y_\theta)^2 \mathrm{~d} \theta\) </span></p> <ul> <li>Remark: At each step, we pick a direction in the color space and take a step of gradient descent to make the colormap of the current iteration closer to the one of \(Y\) in that direction.</li> </ul> <h2><u>Results</u></h2> <p>Here are the results obtained by applying the algorithm with 100 iterations and \(\epsilon=1\) to transport the first image, \(X\), to the colormap of the 5 other images, denoted as \(Y\):</p> <p><img src="/assets/img/Transported_images.png" alt="A sample image" style="width: 100%; height: auto; margin: 0; position: absolute; left: 0;"></p> <h2>$$\;$$</h2> <h2>$$\;$$</h2> <h2>$$\;$$</h2> <h2>$$\;$$</h2> <h2>$$\;$$</h2> <h2>$$\;$$</h2> <h2>$$\;$$</h2> </div> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?c9d9dd48933de3831b3ee5ec9c209cac" type="text/javascript"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>